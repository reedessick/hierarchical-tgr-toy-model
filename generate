#!/usr/bin/env python3

"""generate mock catalogs
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import numpy as np

import h5py

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot as plt
plt.rcParams['text.usetex'] = True

import corner

from argparse import ArgumentParser

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('num', type=int)

parser.add_argument('target', type=str)

parser.add_argument('--dphi-mode', default='scaled_normal', type=str)
parser.add_argument('--seed', default=None, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')

args = parser.parse_args()

#-------------------------------------------------

if args.seed:
    if args.verbose:
        print('setting numpy.random.seed(%d)' % args.seed)
    np.random.seed(args.seed)

#-------------------------------------------------

meta = dict(
    num=args.num,
    dphi_mode=args.dphi_mode,
    min_M = 10,
    max_M = 100,
    min_q = 0.1,
    max_q = 1.0,
    min_s = -1.0,
    max_s = +1.0,
    mean0 = 1.0,
    stdv0 = 2.0,
    exp_mean = -2.0,
    exp_stdv = -2.0,
)

#------------------------

# draw total mass and mass ratio
if args.verbose:
    print('drawing %d total mass samples uniformly between %f - %f' % (args.num, meta['min_M'], meta['max_M']))
M = np.random.random(args.num) * (meta['max_M'] - meta['min_M']) + meta['min_M']
logprob_M = np.ones(args.num, dtype=float) / (meta['max_M'] - meta['min_M'])

#------------------------

# draw mass ratio samples
if args.verbose:
    print('drawing %d mass ratio samples uniformly between %f - %f' % (args.num, meta['min_q'], meta['max_q']))
q = np.random.random(args.num) * (meta['max_q'] - meta['min_q']) + meta['min_q']
logprob_q = np.ones(args.num, dtype=float) / (meta['max_q'] - meta['min_q'])

#------------------------

# draw spin samples
if args.verbose:
    print('drawing %d spin samples uniformly between %f - %f for each component separately' % \
        (args.num, meta['min_s'], meta['max_s']))

s1, s2 = np.random.random((2, args.num)) * (meta['max_s'] - meta['min_s']) + meta['min_s']
logprob_s1 = np.ones(args.num, dtype=float) / (meta['max_s'] - meta['min_s'])
logprob_s2 = np.ones(args.num, dtype=float) / (meta['max_s'] - meta['min_s'])

#------------------------

if args.verbose:
    print('drawing %d dphi samples with mode=%s' % (args.num, args.dphi_mode))

if args.dphi_mode == 'scaled_normal':
    mean = meta['mean0'] * M**meta['exp_mean']
    stdv = meta['stdv0'] * M**meta['exp_stdv']

    dphi = mean + stdv*np.random.normal(size=args.num)
    logprob_dphi = -0.5*((dphi-mean)/stdv)**2 - 0.5*np.log(2*np.pi) - np.log(stdv)

elif args.dphi_mode == 'scaled_exp_abs':
    mean = meta['mean0'] * M**meta['exp_mean']
    stdv = meta['stdv0'] * M**meta['exp_stdv']
    gamma = 2**0.5/stdv

    # inverse-transform sample
    dphi = (-np.log(1 - np.random.random(size=args.num)) / gamma) * np.where(np.random.random(size=args.num)>0.5, +1, -1)
    dphi += mean
    
    logprob_dphi = -gamma*np.abs(dphi-mean) + np.log(0.5) + np.log(gamma)

elif args.dphi_mode == 'scaled_exp':
    mean = meta['mean0'] * M**meta['exp_mean']
    stdv = meta['stdv0'] * M**meta['exp_stdv']

    gamma = 1/stdv
    a = mean - 1/gamma

    dphi = (-np.log(1 - np.random.random(size=args.num)) / gamma) + a
    logprob_dphi = -gamma*(dphi - a) + np.log(gamma)

elif args.dphi_mode == 'scaled_normal_q':
    mean = meta['mean0'] * M**meta['exp_mean'] * (1 - np.exp(q/0.25)) # just some strong function of q
    stdv = meta['stdv0'] * M**meta['exp_stdv'] * np.exp(q/0.25)

    dphi = mean + stdv*np.random.normal(size=args.num)
    logprob_dphi = -0.5*((dphi-mean)/stdv)**2 - 0.5*np.log(2*np.pi) - np.log(stdv)

elif args.dphi_mode == 'deterministic':
    meta['stdv0'] = 0.0
    dphi = meta['mean0'] * M**meta['exp_mean']
    logprob_dphi = np.zeros(args.num, dtype=float) # set this to be constant because this is deterministic

elif args.dphi_mode == 'sGB':
    dphi = (10/M)**4 * ((s2 - s1*q**2)**2/(1+q)**4)
    logprob_dphi = np.zeros(args.num, dtype=float) # set this to be constant because this is determinstic

else:
    raise ValueError('--dphi=%s not understood' % args.dpi)

#------------------------

if args.verbose:
    print('writing catalog to: '+args.target)

with h5py.File(args.target, 'w') as obj:
    for k, v in meta.items():
        obj.attrs.create(k, v)

    if args.seed is not None:
        obj.attrs.create('seed', args.seed)

    obj.create_dataset('M', data=M)
    obj.create_dataset('logprob_M', data=logprob_M)

    obj.create_dataset('q', data=q)
    obj.create_dataset('logprob_q', data=logprob_q)

    obj.create_dataset('s1', data=s1)
    obj.create_dataset('logprob_s1', data=logprob_s1)

    obj.create_dataset('s2', data=s2)
    obj.create_dataset('logprob_s2', data=logprob_s2)

    obj.create_dataset('dphi', data=dphi)
    obj.create_dataset('logprob_dphi', data=logprob_dphi)

#------------------------

if args.verbose:
    print('plotting')

fig = corner.corner(
    np.transpose([M, q, dphi]),
    labels=['$M$', '$q$', '$\delta\phi$'],
)

fig.suptitle('dphi_mode=%s\n%d events' % (args.dphi_mode, args.num))

for ax in fig.axes:
    ax.tick_params(direction='in', which='both')

figname = args.target[:-3] + 'png' # FIXME? could be fragile
if args.verbose:
    print('    saving: '+figname)
fig.savefig(figname)
plt.close(fig)

#!/usr/bin/env python3

"""a quick inference script
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import numpy as np

import h5py

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot as plt
plt.rcParams['text.usetex'] = True

import corner

import jax
from jax import random
from jax import numpy as jnp
from jax.scipy.special import logsumexp as jlogsumexp

import numpyro
from numpyro import handlers
import numpyro.distributions as dist
from numpyro.infer import (MCMC, NUTS, init_to_value)

numpyro.enable_x64() # improve default numerical precision

from argparse import ArgumentParser

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('catalog', type=str)
parser.add_argument('samples', type=str)

parser.add_argument('--mode', default='normal', type=str,
    help='what type of distribution to assume within recovery')

parser.add_argument('--one-scaling', default=False, action='store_true')
parser.add_argument('--fix', default=[], type=str, action='append', nargs=2)

parser.add_argument('--seed', default=123, type=int)

parser.add_argument('--num-warmup', default=1000, type=int)
parser.add_argument('--num-samples', default=10000, type=int)

parser.add_argument('--num-warmup-prior', default=None, type=int)
parser.add_argument('--num-samples-prior', default=None, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')

args = parser.parse_args()

fixed = dict((k, float(v)) for k, v in args.fix)

#-------------------------------------------------

if args.verbose:
    print('loading catalog from: '+args.catalog)

with h5py.File(args.catalog, 'r') as obj:
    meta = dict(obj.attrs.items())
    data = dict((k, obj[k][:]) for k in obj.keys())

if args.verbose:
    print('    found %d events' % meta['num'])

#------------------------

# define model

if args.verbose:
    print('defining model with mode=%s' % args.mode)

if args.mode == 'normal':

    def prior(one_scaling, **ignored):
        # draw hyperparameters
        mean0 = numpyro.sample('mean0', dist.Normal(0.0, 5.0))
        stdv0 = numpyro.sample('stdv0', dist.Chi2(2.0))

        exp_mean = numpyro.sample('exp_mean', dist.Normal(-2.0, 5.0))
        if one_scaling:
            exp_stdv = numpyro.deterministic('exp_stdv', exp_mean)
        else:
            exp_stdv = numpyro.sample('exp_stdv', dist.Normal(-2.0, 5.0))

        return mean0, stdv0, exp_mean, exp_stdv

    def model(one_scaling, **ignored):
        mean0, stdv0, exp_mean, exp_stdv = prior(one_scaling)

        mean = mean0 * data['M']**exp_mean
        stdv = stdv0 * data['M']**exp_stdv

        numpyro.sample('dphi', dist.Normal(mean, stdv), obs=data['dphi'])

        # this does not work for some reason...
#        z = (data['dphi'] - mean) / stdv # convert to z-score
#        numpyro.sample('dphi', dist.Normal(0, 1), obs=z)

#---

elif args.mode == 'student_t':
    def prior(one_scaling, num_dof=None, **ignored):
        # draw hyperparameters
        mean0 = numpyro.sample('mean0', dist.Normal(0.0, 5.0))
        stdv0 = numpyro.sample('stdv0', dist.Chi2(2.0))

        exp_mean = numpyro.sample('exp_mean', dist.Normal(-2.0, 5.0))
        if one_scaling:
            exp_stdv = numpyro.deterministic('exp_stdv', exp_mean)
        else:
            exp_stdv = numpyro.sample('exp_stdv', dist.Normal(-2.0, 5.0))

        if num_dof is None:
            num_dof = numpyro.sample('num_dof', dist.Chi2(4.0)) # FIXME? not sure what number of DOF for prior is best...
        else:
            num_dof = numpyro.deterministic('num_dof', num_dof)

        return mean0, stdv0, exp_mean, exp_stdv, num_dof

    def model(one_scaling, num_dof=None, **ignored):
        mean0, stdv0, exp_mean, exp_stdv, num_dof = prior(one_scaling, num_dof=num_dof)

        mean = mean0 * data['M']**exp_mean
        stdv = stdv0 * data['M']**exp_stdv

        numpyro.sample('dphi', dist.StudentT(num_dof, mean, stdv), obs=data['dphi'])

        # this does not work for some reason...
#        t = (data['dphi'] - mean)/(stdv/(num_dof/(num_dof-2))**0.5) # convert to t-score
#        numpyro.sample('dphi', dist.StudentT(num_dof), obs=t)

#---

elif args.mode == 'noncentral_student_t':
    def prior(one_scaling, num_dof=None, noncentral=None, **ignored):
        # draw hyperparameters
        mean0 = numpyro.sample('mean0', dist.Normal(0.0, 5.0))
        stdv0 = numpyro.sample('stdv0', dist.Chi2(2.0))

        exp_mean = numpyro.sample('exp_mean', dist.Normal(-2.0, 5.0))
        if one_scaling:
            exp_stdv = numpyro.deterministic('exp_stdv', exp_mean)
        else:
            exp_stdv = numpyro.sample('exp_stdv', dist.Normal(-2.0, 5.0))

        if num_dof is None:
            num_dof = numpyro.sample('num_dof', dist.Chi2(4.0)) # FIXME? not sure what number of DOF for prior is best...
        else:
            num_dof = numpyro.deterministic('num_dof', num_dof)

        if noncentral is None:
            noncentral = numpyro.sample('noncentral', dist.Normal(0.0, 4.0)) # FIXME? also not sure about prior for this...
        else:
            noncentral = numpyro.deterministic('noncentral', noncentral)

        return mean0, stdv0, exp_mean, exp_stdv, num_dof, noncentral

    def model(one_scaling, num_dof=None, noncentral=None, **ignored):
        mean0, stdv0, exp_mean, exp_stdv, num_dof, noncentral = prior(one_scaling, num_dof=num_dof, noncentral=noncentral)

        mean = mean0 * data['M']**exp_mean
        stdv = stdv0 * data['M']**exp_stdv

        raise NotImplementedError('''
need to figure out how to compare to noncentral student-t variable

nct = (Z+noncentral)/(V/num_dof)**0.5

where
    Z ~ Normal(0, 1)
    V ~ Chi2(num_dof)
''')

#---

else:
    raise ValueError('--mode=%s not understood' % args.mode)

#------------------------    

# run sampler

if args.verbose:
    if fixed:
        print('fixing hyperparameters')
        for k, v in fixed.items():
            print('    %s = %.3f' % (k, v))
    if args.one_scaling:
        print('forcing scaling with M to be identical between mean and stdv')

num_warmup_prior = args.num_warmup_prior if args.num_warmup_prior is not None else args.num_warmup
num_samples_prior = args.num_samples_prior if args.num_samples_prior is not None else args.num_samples

if args.verbose:
    print('drawing %d samples from the prior with %d warmup and seed=%d' % \
        (num_samples_prior, num_warmup_prior, args.seed))

mcmc = MCMC(
    NUTS(prior),
    num_warmup=num_warmup_prior,
    num_samples=num_samples_prior,
)
mcmc.run(random.PRNGKey(args.seed), args.one_scaling, **fixed)
prior_samples = mcmc.get_samples()

#---

if args.verbose:
    print('drawing %d samples from the posterior with %d warmup and seed=%d' % \
        (args.num_samples, args.num_warmup, args.seed))

mcmc = MCMC(NUTS(model), num_warmup=args.num_warmup, num_samples=args.num_samples)
mcmc.run(random.PRNGKey(args.seed), args.one_scaling, **fixed)
posterior_samples = mcmc.get_samples()

#------------------------

# save samples

if args.verbose:
    print('writing samples to: '+args.samples)

with h5py.File(args.samples, 'w') as obj:
    grp = obj.create_group('prior')
    for k, v in prior_samples.items():
        grp.create_dataset(k, data=v)

    grp = obj.create_group('posterior')
    for k, v in posterior_samples.items():
        grp.create_dataset(k, data=v)

#------------------------

# make a simple figure

if args.verbose:
    print('plotting')

keys = ['mean0', 'stdv0', 'exp_mean', 'exp_stdv']
labels = ['$\mu_0$', '$\sigma_0$', '$p_\mu$', '$p_\sigma$']
truth = [meta['mean0'], meta['stdv0'], meta['exp_mean'], meta['exp_stdv']]

if args.mode == 'student_t':
    keys.append('num_dof')
    labels.append('num_dof')
    truth.append(None)

elif args.mode == 'noncentral_student_t':
    keys += ['num_dof', 'noncentral']
    labels += ['num_dof', 'noncentral']
    truth += [None, None]

#---

### prior

ranges = []
for key in keys:
    m = min(np.min(prior_samples[key]), meta[key])
    M = max(np.max(prior_samples[key]), meta[key])
    d = max(0.01, (M-m)*0.1)
    ranges.append((m-d, M+d))

fig = corner.corner(
    np.transpose([prior_samples[key] for key in keys]),
    color='b',
    truths=truth,
    truth_color='k',
    range=ranges,
    hist_kwargs=dict(density=True),
    bins=min(100, max(10, int(0.3*num_samples_prior**0.5))),
)

#---

### posterior

ranges = []
for key in keys:
    m = min(np.min(posterior_samples[key]), meta[key])
    M = max(np.max(posterior_samples[key]), meta[key])
    d = max(0.01, (M-m)*0.1)
    ranges.append((m-d, M+d))

fig = corner.corner(
    np.transpose([posterior_samples[key] for key in keys]),
    color='r',
    labels=labels,
    range=ranges,
    hist_kwargs=dict(histtype='stepfilled', alpha=0.50, density=True),
    bins=min(100, max(10, int(0.3*args.num_samples**0.5))),
    fig=fig,
)

### decorate

fig.text(0.9, 0.900, 'truth', color='k', ha='center')
fig.text(0.9, 0.875, 'prior', color='b', ha='center')
fig.text(0.9, 0.850, 'posterior', color='r', ha='center')

if args.mode == 'normal':
    fig.suptitle('''\
$\delta \phi \sim \mathcal{N}(\mu, \sigma)$
$\mu = \mu_0  M^{p_\mu}$
$\sigma = \sigma_0 M^{p_\sigma}$''')

for ax in fig.axes:
    ax.tick_params(direction='in', which='both')

### save

figname = args.samples[:-3] + 'png' # FIXME! could be fragile!
if args.verbose:
    print('    saving: '+figname)
fig.savefig(figname)
plt.close(fig)
